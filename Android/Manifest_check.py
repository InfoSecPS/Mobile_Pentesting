import xml.etree.ElementTree as ET
import sys
from colorama import init, Fore, Style

# Initialize colorama
init(autoreset=True)

def parse_manifest(file_path):
    return ET.parse(file_path).getroot()

def check_package_name(root):
    package = root.get('package')
    if package:
        # Check if the package name follows the recommended format
        parts = package.split('.')
        if len(parts) >= 2 and all(part.isalnum() for part in parts):
            return f"The package name is: {Fore.GREEN}{package}"
        else:
            return f"Warning: Package name {package} may not follow best practices"
    else:
        return "Warning: No package name found in the manifest"  

def check_debuggable(root):
    app = root.find("application")
    if app is not None and app.get("{http://schemas.android.com/apk/res/android}debuggable") == "true":
        return "Warning: debuggable is set to true. Information may be explosed in Logcat."
    return None

def check_allowbackup(root):
    app = root.find("application")
    if app is not None and app.get("{http://schemas.android.com/apk/res/android}allowBackup") == "true":
        return "Note: allowBackup is set to true. Consider using Android Backup Extractor."
    return None
     
    
def check_sdk_versions(root):
    issues = []
    
    # Check compileSdkVersion
    compile_sdk = root.get('android:compileSdkVersion')
    if compile_sdk:
        try:
            sdk_version = int(compile_sdk)
            if sdk_version < 26:  # Android 8.0 (API level 26)
                issues.append(f"Warning: compileSdkVersion {sdk_version} is below the recommended minimum of 26 (Android 8.0).")
        except ValueError:
            issues.append(f"Warning: compileSdkVersion '{compile_sdk}' is not a valid integer.")
    else:
        issues.append("Warning: compileSdkVersion is not specified in the manifest.")

    # Check compileSdkVersionCodename
    compile_sdk_codename = root.get('android:compileSdkVersionCodename')
    if compile_sdk_codename:
        if compile_sdk_codename.lower() not in ['r', 's', 't', 'u', 'v']:  # Recent Android version codenames
            issues.append(f"Warning: compileSdkVersionCodename '{compile_sdk_codename}' might be outdated.")
    
    # Check platformBuildVersionCode
    platform_build_version_code = root.get('platformBuildVersionCode')
    if platform_build_version_code:
        try:
            build_version = int(platform_build_version_code)
            if build_version < 26:  # Android 8.0 (API level 26)
                issues.append(f"Warning: platformBuildVersionCode {build_version} is below the recommended minimum of 26 (Android 8.0).")
        except ValueError:
            issues.append(f"Warning: platformBuildVersionCode '{platform_build_version_code}' is not a valid integer.")
    else:
        issues.append("Warning: platformBuildVersionCode is not specified in the manifest.")

    # Check for uses-sdk element (for backwards compatibility)
    uses_sdk = root.find("uses-sdk")
    if uses_sdk is not None:
        min_sdk = uses_sdk.get('{http://schemas.android.com/apk/res/android}minSdkVersion')
        target_sdk = uses_sdk.get('{http://schemas.android.com/apk/res/android}targetSdkVersion')
        
        if min_sdk:
            try:
                min_sdk_version = int(min_sdk)
                if min_sdk_version < 21:  # Android 5.0 (API level 21)
                    issues.append(f"Warning: minSdkVersion {min_sdk_version} is below the recommended minimum of 21 (Android 5.0).")
            except ValueError:
                issues.append(f"Warning: minSdkVersion '{min_sdk}' is not a valid integer.")
        
        if target_sdk:
            try:
                target_sdk_version = int(target_sdk)
                if target_sdk_version < 26:  # Android 8.0 (API level 26)
                    issues.append(f"Warning: targetSdkVersion {target_sdk_version} is below the recommended minimum of 26 (Android 8.0).")
            except ValueError:
                issues.append(f"Warning: targetSdkVersion '{target_sdk}' is not a valid integer.")

    return issues if issues else None     

def check_exported_components(root):
    issues = []
    for comp in root.findall(".//activity") + root.findall(".//service") + root.findall(".//receiver"):
        if comp.get("{http://schemas.android.com/apk/res/android}exported") == "true":
            name = comp.get("{http://schemas.android.com/apk/res/android}name")
            issues.append(f"Warning: {name} is exported. Manually check using ADB for data exposure or inputs.")
    return issues if issues else None

def check_permissions(root):
    dangerous_permissions = [
        "android.permission.READ_CALENDAR",
        "android.permission.WRITE_CALENDAR",
        "android.permission.CAMERA",
        "android.permission.READ_CONTACTS",
        "android.permission.WRITE_CONTACTS",
        "android.permission.GET_ACCOUNTS",
        "android.permission.ACCESS_FINE_LOCATION",
        "android.permission.ACCESS_COARSE_LOCATION",
        "android.permission.ACCESS_BACKGROUND_LOCATION",
        "android.permission.RECORD_AUDIO",
        "android.permission.READ_PHONE_STATE",
        "android.permission.READ_PHONE_NUMBERS",
        "android.permission.CALL_PHONE",
        "android.permission.ANSWER_PHONE_CALLS",
        "android.permission.READ_CALL_LOG",
        "android.permission.WRITE_CALL_LOG",
        "android.permission.ADD_VOICEMAIL",
        "android.permission.USE_SIP",
        "android.permission.PROCESS_OUTGOING_CALLS",
        "android.permission.BODY_SENSORS",
        "android.permission.SEND_SMS",
        "android.permission.RECEIVE_SMS",
        "android.permission.READ_SMS",
        "android.permission.RECEIVE_WAP_PUSH",
        "android.permission.RECEIVE_MMS",
        "android.permission.READ_EXTERNAL_STORAGE",
        "android.permission.WRITE_EXTERNAL_STORAGE",
        "android.permission.MANAGE_EXTERNAL_STORAGE",
        "android.permission.ACCESS_MEDIA_LOCATION",
        "android.permission.ACTIVITY_RECOGNITION",
        "android.permission.READ_MEDIA_IMAGES",
        "android.permission.READ_MEDIA_VIDEO",
        "android.permission.READ_MEDIA_AUDIO",
        "android.permission.NEARBY_WIFI_DEVICES",
        "android.permission.POST_NOTIFICATIONS",
        "android.permission.BLUETOOTH_SCAN",
        "android.permission.BLUETOOTH_CONNECT",
        "android.permission.BLUETOOTH_ADVERTISE",
        "android.permission.UWB_RANGING"
    ]
    issues = []
    for perm in root.findall("uses-permission"):
        if perm.get("{http://schemas.android.com/apk/res/android}name") in dangerous_permissions:
            issues.append(f"Note: Using potentially dangerous permission: {perm.get('{http://schemas.android.com/apk/res/android}name')}")
    return issues if issues else None

def check_cleartextTraffic(root):
    app = root.find("application")
    if app is not None and app.get("{http://schemas.android.com/apk/res/android}usesCleartextTraffic") == "true":
        return "Warning: cleartextTraffic is allowed. Check source code for references to insecure protocols."
    return None

def analyze_manifest(file_path):
    root = parse_manifest(file_path)
    checks = [
        ("Package Name", check_package_name),
        ("Debuggable Check", check_debuggable),
        ("Backup Check", check_allowbackup),
        ("Exported Components Check", check_exported_components),
        ("Permissions Check", check_permissions),
        ("Cleartext Traffic Check", check_cleartextTraffic),
        ("Check SDK Versions", check_sdk_versions)
    ]
    
    issues = []
    for title, check in checks:
        print(f"\n{Fore.CYAN}{Style.BRIGHT}=== {title} ==={Style.RESET_ALL}")
        result = check(root)
        if result:
            if isinstance(result, list):
                issues.extend(result)
                for item in result:
                    print(f"{Fore.YELLOW}- {item}")
            else:
                issues.append(result)
                print(f"{Fore.YELLOW}- {result}")
        else:
            print(f"{Fore.GREEN}No issues found.")
    
    return issues

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"{Fore.RED}Usage: python script.py path_to_AndroidManifest.xml")
        sys.exit(1)
    
    manifest_path = sys.argv[1]
    issues = analyze_manifest(manifest_path)
    
    print(f"\n{Fore.CYAN}{Style.BRIGHT}=== Summary ==={Style.RESET_ALL}")
    if issues:
        print(f"{Fore.YELLOW}[{len(issues)}] potential issue(s) found.")
        print("   ")
        print(f"{Fore.YELLOW}[+] Please conduct a manual inspection to verify the results!")
        print("   ")
    else:
        print(f"{Fore.GREEN}No issues found.")
